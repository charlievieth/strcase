//go:build gen
// +build gen

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"unicode"
	"unicode/utf8"

	"golang.org/x/text/unicode/rangetable"
)

func init() {
	log.SetPrefix("[gen] ")
	log.SetFlags(log.Lshortfile)
}

var categories = rangetable.Merge(mapToTable(unicode.Categories))

func mapToTable(maps ...map[string]*unicode.RangeTable) *unicode.RangeTable {
	n := 0
	for _, m := range maps {
		n += len(m)
	}
	tabs := make([]*unicode.RangeTable, 0, n)
	for _, m := range maps {
		for _, t := range m {
			tabs = append(tabs, t)
		}
	}
	return rangetable.Merge(tabs...)
}

func printRangeTable(w *bytes.Buffer, name string, rt *unicode.RangeTable) {
	rt = rangetable.Merge(rt) // Optimize

	fmt.Fprintf(w, "var %s = &unicode.RangeTable{\n", name)
	if len(rt.R16) == 0 {
		fmt.Fprintln(w, "\tR16: []unicode.Range16{},")
	} else {
		fmt.Fprintln(w, "\tR16: []unicode.Range16{")
		for _, r := range rt.R16 {
			// %#04x
			// fmt.Fprintf(w, "\t\t{0x%x, 0x%x, %d},\n", r.Lo, r.Hi, r.Stride)
			fmt.Fprintf(w, "\t\t{%#04x, %#04x, %d},\n", r.Lo, r.Hi, r.Stride)
		}
		fmt.Fprintln(w, "\t},")
	}
	if len(rt.R32) == 0 {
		fmt.Fprintln(w, "\tR32: []unicode.Range32{},")
	} else {
		fmt.Fprintln(w, "\tR32: []unicode.Range32{")
		for _, r := range rt.R32 {
			fmt.Fprintf(w, "\t\t{%#06x, %#06x, %d},\n", r.Lo, r.Hi, r.Stride)
		}
		fmt.Fprintln(w, "\t},")
	}
	fmt.Fprintln(w, "}")
}

func folds(sr rune) []rune {
	r := unicode.SimpleFold(sr)
	runes := make([]rune, 1, 2)
	runes[0] = sr
	for r != sr {
		runes = append(runes, r)
		r = unicode.SimpleFold(r)
	}
	return runes
}

func genMustLower(w *bytes.Buffer) {
	var runes []rune
	rangetable.Visit(categories, func(r rune) {
		if ff := folds(r); len(ff) > 2 {
			runes = append(runes, ff...)
			return
		}
		switch lr := unicode.ToLower(r); {
		case r >= utf8.RuneSelf && lr < utf8.RuneSelf:
			runes = append(runes, r, lr, unicode.ToUpper(lr))
		case unicode.ToUpper(r) != unicode.ToUpper(lr):
			runes = append(runes, r, lr, unicode.ToUpper(lr))
		}
	})

	if len(runes) == 0 {
		log.Panic("Failed to generate any runes!")
	}

	table := rangetable.New(runes...)
	printRangeTable(w, "_MustLower", table)
}

func writeHeader(w *bytes.Buffer) {
	const hdr = `// Code generated by running "go generate" in github.com/charlievieth/strcase. DO NOT EDIT.

package strcase

import "unicode"

`
	w.WriteString(hdr)
}

func sameData(filename string, data []byte) bool {
	got, _ := os.ReadFile(filename)
	return bytes.Equal(got, data)
}

func writeFile(name string, data []byte) {
	if got, _ := os.ReadFile(name); bytes.Equal(got, data) {
		return
	}
	if err := os.WriteFile(name+".tmp", data, 0644); err != nil {
		log.Panic(err)
	}
	if err := os.Rename(name+".tmp", name); err != nil {
		log.Panic(err)
	}
}

func main() {
	var w bytes.Buffer

	writeHeader(&w)
	genMustLower(&w)
	src, err := format.Source(w.Bytes())
	if err != nil {
		log.Panic(err)
	}
	writeFile("tables.go", src)
}
